import {
    extend,
    DataItem,
    RegistryItem,
    DataItemMap
  } from "@keystonehq/bc-ur-registry";
import { ExtendedRegistryTypes } from "./RegistryType";
import { languages } from "./LanguageCodes";

const { RegistryTypes, decodeToDataItem } = extend;

/** CDDL
 * 
 * metadata = {
 * 		? sync_id: bytes .size 16     ; Generated by the hardware wallet to identify 
 * the device
 * 		? language: language_code,    ; Indicates the selected language selected 
 * on the hardware wallet
 * 		? fw_version: string,         ; Firmware version of the hardware wallet
 * 		? device: string              ; Indicates the device name
 * 		* tstr => any                 ; Extendable new metadata
 * }
 * 
 * sync_id = 1
 * language = 2
 * fw_version = 3
 * device = 4
 * 
 * language_code = string ; following [ISO 639-1] Code (e.g. "en" for English, 
 * "fr" for French, "nl" for Dutch and "es" for Spanish
 * 
 */

enum Keys {
  sync_id = 1,
  language = 2,
  fw_version = 3,
  device = 4,
}

interface ICryptoSyncMetadata {
  sync_id?: Buffer; // Size 16
  language_code?: keyof typeof languages; // ISO 639-1 language codes
  fw_version?: string;
  device?: string;
  //[key: string]: any;
}


export class CryptoSyncMetadata extends RegistryItem {
  private sync_id?: Buffer; // Size 16
  private language_code?: keyof typeof languages; // ISO 639-1 language codes
  private fw_version?: string;
  private device?: string;
  // Any any

  //private metadata: ICryptoSyncMetadata;

  getRegistryType = () => ExtendedRegistryTypes.CRYPTO_SYNC_METADATA;

  constructor(private metadata: ICryptoSyncMetadata = {}) {
    super();

    // If language code is incorrect, throw error
    if (metadata.language_code && !languages[metadata.language_code]) {
      throw new Error("Invalid language code");
    }

    // sync id buffer size must be maximum 16 otherwise throw error
    if (metadata.sync_id && metadata.sync_id.length > 16) {
      throw new Error("Sync id buffer size must be maximum 16");
    }

    // TODO: make firmware version valid SemVer

  }

  public getSyncId = () => {
    // should pad the left of the buffer with 0 if smaller than 16
    if (this.metadata.sync_id) {
      return Buffer.concat([
        Buffer.alloc(16 - this.metadata.sync_id.length),
        this.metadata.sync_id,
      ]);
    }
  }

  public getLanguageCode = () => this.metadata.language_code;
  public getFirmwareVersion = () => this.metadata.fw_version;
  public getDevice = () => this.metadata.device;

  public toDataItem = () => {
    const map: DataItemMap = {};

    let padRemovedSyncId = this.metadata.sync_id;
    // Remove starting zeros from sync id buffer
    while (padRemovedSyncId && padRemovedSyncId[0] === 0) {
      padRemovedSyncId = padRemovedSyncId.slice(1);
    }

    map[Keys.sync_id] = padRemovedSyncId;
    map[Keys.language] = this.metadata.language_code;
    map[Keys.fw_version] = this.metadata.fw_version;
    map[Keys.device] = this.metadata.device;

    // Todo add any by incrementing the map key

    return new DataItem(map);
  };

  public static fromDataItem = (dataItem: DataItem) => {
    const map = dataItem.getData();

    const sync_id = map[Keys.sync_id];
    const language_code = map[Keys.language];
    const fw_version = map[Keys.fw_version];
    const device = map[Keys.device];
    // TODO: Could be anything as json. import anything

    return new CryptoSyncMetadata({sync_id, language_code, fw_version, device});
  }

  public static fromCBOR = (_cborPayload: Buffer) => {
    const dataItem = decodeToDataItem(_cborPayload);
    return CryptoSyncMetadata.fromDataItem(dataItem);
  };
}
  