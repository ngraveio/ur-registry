import {
    extend,
    DataItem,
    RegistryItem,
    DataItemMap
  } from "@keystonehq/bc-ur-registry";
import { ExtendedRegistryTypes } from "./RegistryType";
import { languages } from "./LanguageCodes";

const { RegistryTypes, decodeToDataItem } = extend;

/** CDDL
 * 
 * metadata = {
 * 		? sync_id: bytes .size 16     ; Generated by the hardware wallet to identify 
 * the device
 * 		? language: language_code,    ; Indicates the selected language selected 
 * on the hardware wallet
 * 		? fw_version: string,         ; Firmware version of the hardware wallet
 * 		? device: string              ; Indicates the device name
 * 		* tstr => any                 ; Extendable new metadata
 * }
 * 
 * sync_id = 1
 * language = 2
 * fw_version = 3
 * device = 4
 * 
 * language_code = string ; following [ISO 639-1] Code (e.g. "en" for English, 
 * "fr" for French, "nl" for Dutch and "es" for Spanish
 * 
 */

enum Keys {
  syncId = 1,
  language = 2,
  firmwareVersion = 3,
  device = 4,
}

interface ICryptoPortfolioMetadata {
  syncId?: Buffer; // Size 16
  languageCode?: keyof typeof languages; // ISO 639-1 language codes
  firmwareVersion?: string;
  device?: string;
  [key: string]: any;
}


export class CryptoPortfolioMetadata extends RegistryItem {
  //private metadata: ICryptoPortfolioMetadata;

  getRegistryType = () => ExtendedRegistryTypes.CRYPTO_SYNC_METADATA;

  constructor(private metadata: ICryptoPortfolioMetadata = {}) {
    super();

    // If language code is incorrect, throw error
    if (metadata.languageCode && !languages[metadata.languageCode]) {
      throw new Error("Invalid language code");
    }

    // sync id buffer size must be maximum 16 otherwise throw error
    if (metadata.syncId && metadata.syncId.length > 16) {
      throw new Error("Sync id buffer size must be maximum 16");
    }

    // TODO: make firmware version valid SemVer

  }

  public getSyncId = () => {
    // should pad the left of the buffer with 0 if smaller than 16
    if (this.metadata.syncId) {
      return Buffer.concat([
        Buffer.alloc(16 - this.metadata.syncId.length),
        this.metadata.syncId,
      ]);
    }
  }

  public getLanguageCode = () => this.metadata.languageCode;
  public getFirmwareVersion = () => this.metadata.firmwareVersion;
  public getDevice = () => this.metadata.device;

  
  public getData = () => {
    return {...this.metadata}
  }

  public toDataItem = () => {
    // Lets create an empty map
    let map: DataItemMap = {};

    let padRemovedSyncId = this.metadata.syncId;
    // Remove starting zeros from sync id buffer
    while (padRemovedSyncId && padRemovedSyncId[0] === 0) {
      padRemovedSyncId = padRemovedSyncId.slice(1);
    }

    // Add all known types to the map with integer keys
    map[Keys.syncId] = padRemovedSyncId;
    map[Keys.language] = this.metadata.languageCode;
    map[Keys.firmwareVersion] = this.metadata.firmwareVersion;
    map[Keys.device] = this.metadata.device;

    // Add all unknown types to the map with string keys
    // Clone the metadata object and remove all known types
    const unknownTypes = { ...this.metadata };
    delete unknownTypes.syncId;
    delete unknownTypes.languageCode;
    delete unknownTypes.firmwareVersion;
    delete unknownTypes.device;

    // Add all unknown types to the map
    map = { ...map, ...unknownTypes };

    return new DataItem(map);
  };

  public static fromDataItem = (dataItem: DataItem) => {
    const map = dataItem.getData();

    const syncId = map[Keys.syncId] || map['syncId'];
    const languageCode = map[Keys.language] || map['language'];
    const firmwareVersion = map[Keys.firmwareVersion] || map['firmwareVersion'];
    const device = map[Keys.device] || map['device'];

    // Remove all known types from the map
    for(const key of Object.keys(Keys)) {
      delete map[key];
    }

    return new CryptoPortfolioMetadata({...map, syncId, languageCode, firmwareVersion, device});
  }

  public static fromCBOR = (_cborPayload: Buffer) => {
    const dataItem = decodeToDataItem(_cborPayload);
    return CryptoPortfolioMetadata.fromDataItem(dataItem);
  };
}
  